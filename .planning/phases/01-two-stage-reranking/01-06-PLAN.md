---
phase: 01-two-stage-reranking
plan: 06
type: execute
wave: 4
depends_on: ["01-05"]
files_modified:
  - agent-brain-server/tests/unit/providers/test_reranker_providers.py
  - agent-brain-server/tests/unit/services/test_query_service_reranking.py
  - agent-brain-server/tests/contract/test_query_modes.py
autonomous: true

must_haves:
  truths:
    - "Unit tests cover both reranker providers"
    - "Integration test validates two-stage retrieval flow"
    - "Graceful degradation is tested"
    - "All tests pass with pytest"
  artifacts:
    - path: "agent-brain-server/tests/unit/providers/test_reranker_providers.py"
      provides: "Reranker provider unit tests"
      contains: "test_sentence_transformer_reranker"
    - path: "agent-brain-server/tests/unit/services/test_query_service_reranking.py"
      provides: "Query service reranking integration tests"
      contains: "test_reranking_enabled"
  key_links:
    - from: "tests/unit/providers/test_reranker_providers.py"
      to: "providers/reranker/"
      via: "import and test"
      pattern: "from agent_brain_server.providers.reranker"
---

<objective>
Add comprehensive tests for reranking functionality.

Purpose: Ensure reranking works correctly and degrades gracefully on failure.
Output: Unit tests for providers and integration tests for query service.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-two-stage-reranking/01-RESEARCH.md
@.planning/phases/01-two-stage-reranking/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reranker provider unit tests</name>
  <files>agent-brain-server/tests/unit/providers/test_reranker_providers.py</files>
  <action>
Create the test file with tests for both providers:

```python
"""Unit tests for reranker providers."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from agent_brain_server.config.provider_config import RerankerConfig
from agent_brain_server.providers.base import RerankerProviderType
from agent_brain_server.providers.factory import ProviderRegistry
from agent_brain_server.providers.reranker import (
    RerankerProvider,
    SentenceTransformerRerankerProvider,
    OllamaRerankerProvider,
)


class TestRerankerProtocol:
    """Test RerankerProvider protocol."""

    def test_sentence_transformer_implements_protocol(self):
        """SentenceTransformerRerankerProvider implements RerankerProvider."""
        config = RerankerConfig(
            provider=RerankerProviderType.SENTENCE_TRANSFORMERS,
            model="cross-encoder/ms-marco-MiniLM-L-6-v2",
        )
        provider = SentenceTransformerRerankerProvider(config)
        assert isinstance(provider, RerankerProvider)

    def test_ollama_implements_protocol(self):
        """OllamaRerankerProvider implements RerankerProvider."""
        config = RerankerConfig(
            provider=RerankerProviderType.OLLAMA,
            model="llama3.2:1b",
        )
        provider = OllamaRerankerProvider(config)
        assert isinstance(provider, RerankerProvider)


class TestProviderRegistry:
    """Test provider registration."""

    def test_sentence_transformers_registered(self):
        """SentenceTransformers provider is registered."""
        available = ProviderRegistry.get_available_reranker_providers()
        assert "sentence-transformers" in available

    def test_ollama_registered(self):
        """Ollama provider is registered."""
        available = ProviderRegistry.get_available_reranker_providers()
        assert "ollama" in available

    def test_get_reranker_provider(self):
        """Can get reranker provider from registry."""
        config = RerankerConfig(
            provider=RerankerProviderType.SENTENCE_TRANSFORMERS,
            model="cross-encoder/ms-marco-MiniLM-L-6-v2",
        )
        provider = ProviderRegistry.get_reranker_provider(config)
        assert provider.provider_name == "SentenceTransformers"

    def test_provider_caching(self):
        """Provider instances are cached."""
        config = RerankerConfig(
            provider=RerankerProviderType.SENTENCE_TRANSFORMERS,
            model="cross-encoder/ms-marco-MiniLM-L-6-v2",
        )
        provider1 = ProviderRegistry.get_reranker_provider(config)
        provider2 = ProviderRegistry.get_reranker_provider(config)
        assert provider1 is provider2


class TestSentenceTransformerReranker:
    """Test SentenceTransformerRerankerProvider."""

    @pytest.fixture
    def provider(self):
        """Create provider with mocked CrossEncoder."""
        config = RerankerConfig(
            provider=RerankerProviderType.SENTENCE_TRANSFORMERS,
            model="cross-encoder/ms-marco-MiniLM-L-6-v2",
        )
        return SentenceTransformerRerankerProvider(config)

    def test_provider_name(self, provider):
        """Provider returns correct name."""
        assert provider.provider_name == "SentenceTransformers"

    def test_model_name(self, provider):
        """Provider returns correct model."""
        assert provider.model_name == "cross-encoder/ms-marco-MiniLM-L-6-v2"

    @pytest.mark.asyncio
    async def test_rerank_empty_documents(self, provider):
        """Reranking empty list returns empty list."""
        result = await provider.rerank("query", [], top_k=5)
        assert result == []

    @pytest.mark.asyncio
    async def test_rerank_returns_tuples(self, provider):
        """Rerank returns list of (index, score) tuples."""
        # Mock the CrossEncoder
        with patch.object(provider, "_ensure_model_loaded") as mock_load:
            mock_encoder = MagicMock()
            mock_encoder.rank.return_value = [
                {"corpus_id": 1, "score": 0.9},
                {"corpus_id": 0, "score": 0.7},
            ]
            mock_load.return_value = mock_encoder

            result = await provider.rerank(
                "test query",
                ["doc1", "doc2"],
                top_k=2,
            )

            assert len(result) == 2
            assert result[0] == (1, 0.9)
            assert result[1] == (0, 0.7)


class TestOllamaReranker:
    """Test OllamaRerankerProvider."""

    @pytest.fixture
    def provider(self):
        """Create provider."""
        config = RerankerConfig(
            provider=RerankerProviderType.OLLAMA,
            model="llama3.2:1b",
        )
        return OllamaRerankerProvider(config)

    def test_provider_name(self, provider):
        """Provider returns correct name."""
        assert provider.provider_name == "Ollama"

    def test_model_name(self, provider):
        """Provider returns correct model."""
        assert provider.model_name == "llama3.2:1b"

    def test_parse_score_valid_integer(self, provider):
        """Parse score handles integer."""
        assert provider._parse_score("8") == 8.0

    def test_parse_score_valid_float(self, provider):
        """Parse score handles float."""
        assert provider._parse_score("7.5") == 7.5

    def test_parse_score_with_text(self, provider):
        """Parse score extracts number from text."""
        assert provider._parse_score("The score is 9") == 9.0

    def test_parse_score_invalid(self, provider):
        """Parse score returns 0 for invalid input."""
        assert provider._parse_score("no number here") == 0.0

    def test_parse_score_clamps_high(self, provider):
        """Parse score clamps to max 10."""
        assert provider._parse_score("15") == 10.0

    @pytest.mark.asyncio
    async def test_rerank_empty_documents(self, provider):
        """Reranking empty list returns empty list."""
        result = await provider.rerank("query", [], top_k=5)
        assert result == []

    @pytest.mark.asyncio
    async def test_rerank_with_mock_response(self, provider):
        """Rerank works with mocked HTTP response."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "message": {"content": "8"}
        }
        mock_response.raise_for_status = MagicMock()

        with patch.object(provider, "_get_client") as mock_client:
            mock_http = AsyncMock()
            mock_http.post = AsyncMock(return_value=mock_response)
            mock_client.return_value = mock_http

            result = await provider.rerank(
                "test query",
                ["doc1", "doc2"],
                top_k=2,
            )

            # Both docs should have scores
            assert len(result) == 2
            # Scores should be parsed correctly
            scores = [r[1] for r in result]
            assert all(s == 8.0 for s in scores)


class TestGracefulDegradation:
    """Test graceful degradation scenarios."""

    @pytest.mark.asyncio
    async def test_ollama_handles_connection_error(self):
        """Ollama provider handles connection errors gracefully."""
        config = RerankerConfig(
            provider=RerankerProviderType.OLLAMA,
            model="llama3.2:1b",
        )
        provider = OllamaRerankerProvider(config)

        # Mock connection failure
        with patch.object(provider, "_get_client") as mock_client:
            mock_http = AsyncMock()
            mock_http.post = AsyncMock(
                side_effect=Exception("Connection refused")
            )
            mock_client.return_value = mock_http

            result = await provider.rerank(
                "test query",
                ["doc1", "doc2"],
                top_k=2,
            )

            # Should return results with 0.0 scores (fallback)
            assert len(result) == 2
            assert all(r[1] == 0.0 for r in result)
```

Create the directory if needed:
```bash
mkdir -p agent-brain-server/tests/unit/providers
touch agent-brain-server/tests/unit/providers/__init__.py
```
  </action>
  <verify>Run `cd agent-brain-server && poetry run pytest tests/unit/providers/test_reranker_providers.py -v` to verify all tests pass.</verify>
  <done>Reranker provider unit tests exist and pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create query service reranking tests</name>
  <files>agent-brain-server/tests/unit/services/test_query_service_reranking.py</files>
  <action>
Create integration tests for reranking in query service:

```python
"""Tests for query service reranking integration."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from agent_brain_server.models import QueryRequest, QueryResult, QueryMode
from agent_brain_server.services.query_service import QueryService


class TestQueryServiceReranking:
    """Test query service reranking integration."""

    @pytest.fixture
    def mock_query_service(self):
        """Create query service with mocked dependencies."""
        with patch(
            "agent_brain_server.services.query_service.get_vector_store"
        ) as mock_vs, patch(
            "agent_brain_server.services.query_service.get_embedding_generator"
        ) as mock_eg, patch(
            "agent_brain_server.services.query_service.get_bm25_manager"
        ) as mock_bm25, patch(
            "agent_brain_server.services.query_service.get_graph_index_manager"
        ) as mock_graph:
            mock_vs.return_value.is_initialized = True
            mock_vs.return_value.get_count = AsyncMock(return_value=100)
            mock_vs.return_value.similarity_search = AsyncMock(return_value=[])
            mock_eg.return_value.embed_query = AsyncMock(return_value=[0.1] * 768)
            mock_bm25.return_value.is_initialized = True
            mock_bm25.return_value.search_with_filters = AsyncMock(return_value=[])
            mock_graph.return_value = MagicMock()

            yield QueryService()

    @pytest.fixture
    def sample_results(self):
        """Create sample query results."""
        return [
            QueryResult(
                text=f"Document {i}",
                source=f"doc{i}.txt",
                score=1.0 - (i * 0.1),
                chunk_id=f"chunk_{i}",
            )
            for i in range(10)
        ]

    @pytest.mark.asyncio
    async def test_rerank_results_success(self, mock_query_service, sample_results):
        """_rerank_results applies reranking correctly."""
        # Mock the reranker
        mock_reranker = MagicMock()
        mock_reranker.is_available.return_value = True
        mock_reranker.provider_name = "Mock"
        mock_reranker.rerank = AsyncMock(
            return_value=[(5, 0.95), (2, 0.85), (0, 0.75)]
        )

        with patch(
            "agent_brain_server.services.query_service.load_provider_settings"
        ) as mock_settings, patch(
            "agent_brain_server.services.query_service.ProviderRegistry"
        ) as mock_registry:
            mock_registry.get_reranker_provider.return_value = mock_reranker

            result = await mock_query_service._rerank_results(
                sample_results, "test query", top_k=3
            )

            assert len(result) == 3
            # Check documents are reordered
            assert result[0].text == "Document 5"
            assert result[1].text == "Document 2"
            assert result[2].text == "Document 0"
            # Check rerank scores are set
            assert result[0].rerank_score == 0.95
            # Check original ranks are set
            assert result[0].original_rank == 6  # 1-indexed

    @pytest.mark.asyncio
    async def test_rerank_results_fallback_on_error(
        self, mock_query_service, sample_results
    ):
        """_rerank_results falls back to stage 1 on error."""
        with patch(
            "agent_brain_server.services.query_service.load_provider_settings"
        ) as mock_settings, patch(
            "agent_brain_server.services.query_service.ProviderRegistry"
        ) as mock_registry:
            mock_registry.get_reranker_provider.side_effect = Exception(
                "Provider not found"
            )

            result = await mock_query_service._rerank_results(
                sample_results, "test query", top_k=3
            )

            # Should return first 3 results unchanged
            assert len(result) == 3
            assert result[0].text == "Document 0"

    @pytest.mark.asyncio
    async def test_rerank_results_provider_unavailable(
        self, mock_query_service, sample_results
    ):
        """_rerank_results falls back when provider unavailable."""
        mock_reranker = MagicMock()
        mock_reranker.is_available.return_value = False
        mock_reranker.provider_name = "Mock"

        with patch(
            "agent_brain_server.services.query_service.load_provider_settings"
        ) as mock_settings, patch(
            "agent_brain_server.services.query_service.ProviderRegistry"
        ) as mock_registry:
            mock_registry.get_reranker_provider.return_value = mock_reranker

            result = await mock_query_service._rerank_results(
                sample_results, "test query", top_k=3
            )

            # Should return first 3 results unchanged
            assert len(result) == 3
            assert result[0].text == "Document 0"

    @pytest.mark.asyncio
    async def test_rerank_results_empty_input(self, mock_query_service):
        """_rerank_results handles empty input."""
        result = await mock_query_service._rerank_results([], "test query", top_k=5)
        assert result == []


class TestExecuteQueryWithReranking:
    """Test execute_query with reranking enabled."""

    @pytest.mark.asyncio
    async def test_reranking_disabled_by_default(self):
        """Reranking is disabled by default."""
        from agent_brain_server.config.settings import settings

        assert settings.ENABLE_RERANKING is False

    @pytest.mark.asyncio
    async def test_stage1_topk_calculation(self):
        """Stage 1 top_k is multiplied when reranking enabled."""
        from agent_brain_server.config.settings import Settings

        # Create settings with reranking enabled
        with patch(
            "agent_brain_server.services.query_service.settings",
            Settings(
                ENABLE_RERANKING=True,
                RERANKER_TOP_K_MULTIPLIER=10,
                RERANKER_MAX_CANDIDATES=100,
            ),
        ):
            # With top_k=5, stage1 should be 50
            request = QueryRequest(query="test", top_k=5)
            expected_stage1 = min(5 * 10, 100)
            assert expected_stage1 == 50

            # With top_k=15, stage1 should be capped at 100
            request = QueryRequest(query="test", top_k=15)
            expected_stage1 = min(15 * 10, 100)
            assert expected_stage1 == 100
```

Create the directory if needed:
```bash
mkdir -p agent-brain-server/tests/unit/services
touch agent-brain-server/tests/unit/services/__init__.py
```
  </action>
  <verify>Run `cd agent-brain-server && poetry run pytest tests/unit/services/test_query_service_reranking.py -v` to verify all tests pass.</verify>
  <done>Query service reranking integration tests exist and pass.</done>
</task>

<task type="auto">
  <name>Task 3: Add reranking mode to contract tests</name>
  <files>agent-brain-server/tests/contract/test_query_modes.py</files>
  <action>
Add a test case for reranking in the existing contract tests. Find the test file and add:

```python
class TestRerankingMode:
    """Test two-stage retrieval with reranking."""

    @pytest.mark.asyncio
    async def test_reranking_disabled_returns_normal_results(self):
        """With ENABLE_RERANKING=false, results have no rerank_score."""
        # This tests the default behavior
        from agent_brain_server.config.settings import settings
        assert settings.ENABLE_RERANKING is False

    @pytest.mark.asyncio
    async def test_query_result_has_rerank_fields(self):
        """QueryResult model includes reranking fields."""
        from agent_brain_server.models import QueryResult

        result = QueryResult(
            text="test",
            source="test.py",
            score=0.9,
            chunk_id="c1",
            rerank_score=0.85,
            original_rank=3,
        )
        assert result.rerank_score == 0.85
        assert result.original_rank == 3

    @pytest.mark.asyncio
    async def test_rerank_fields_optional(self):
        """Reranking fields are optional (None by default)."""
        from agent_brain_server.models import QueryResult

        result = QueryResult(
            text="test",
            source="test.py",
            score=0.9,
            chunk_id="c1",
        )
        assert result.rerank_score is None
        assert result.original_rank is None
```

If the file doesn't have a good place to add this, append it at the end.
  </action>
  <verify>Run `cd agent-brain-server && poetry run pytest tests/contract/test_query_modes.py -v -k rerank` to verify the new reranking tests pass.</verify>
  <done>Contract tests include reranking mode validation.</done>
</task>

</tasks>

<verification>
1. All unit tests for providers pass
2. All integration tests for query service pass
3. Contract tests validate reranking fields
4. Tests cover graceful degradation scenarios
5. Run full test suite: `cd agent-brain-server && poetry run pytest`
</verification>

<success_criteria>
- pytest runs without failures
- Test coverage for reranker providers > 80%
- Graceful fallback is explicitly tested
- Empty input edge cases handled
</success_criteria>

<output>
After completion, create `.planning/phases/01-two-stage-reranking/01-06-SUMMARY.md`
</output>
