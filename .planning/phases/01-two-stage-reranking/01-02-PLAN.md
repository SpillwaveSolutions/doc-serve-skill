---
phase: 01-two-stage-reranking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - agent-brain-server/agent_brain_server/providers/reranker/__init__.py
  - agent-brain-server/agent_brain_server/providers/reranker/base.py
  - agent-brain-server/agent_brain_server/providers/factory.py
autonomous: true

must_haves:
  truths:
    - "RerankerProvider protocol defines async rerank method"
    - "BaseRerankerProvider provides common functionality"
    - "ProviderRegistry can register and retrieve reranker providers"
  artifacts:
    - path: "agent-brain-server/agent_brain_server/providers/reranker/__init__.py"
      provides: "Package exports"
      contains: "RerankerProvider"
    - path: "agent-brain-server/agent_brain_server/providers/reranker/base.py"
      provides: "RerankerProvider protocol and BaseRerankerProvider class"
      contains: "class RerankerProvider"
    - path: "agent-brain-server/agent_brain_server/providers/factory.py"
      provides: "Reranker provider registry methods"
      contains: "register_reranker_provider"
  key_links:
    - from: "providers/factory.py"
      to: "providers/reranker/base.py"
      via: "RerankerProvider import"
      pattern: "from.*reranker.*import"
---

<objective>
Create the reranker provider protocol and base class following existing provider patterns.

Purpose: Establish the abstraction layer for reranking providers that enables pluggable implementations.
Output: RerankerProvider protocol, BaseRerankerProvider, and registry integration.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-two-stage-reranking/01-RESEARCH.md
@agent-brain-server/agent_brain_server/providers/base.py
@agent-brain-server/agent_brain_server/providers/factory.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reranker package with base module</name>
  <files>
    agent-brain-server/agent_brain_server/providers/reranker/__init__.py
    agent-brain-server/agent_brain_server/providers/reranker/base.py
  </files>
  <action>
Create the reranker package directory and files:

1. Create `agent-brain-server/agent_brain_server/providers/reranker/__init__.py`:
```python
"""Reranking providers package."""

from agent_brain_server.providers.reranker.base import (
    BaseRerankerProvider,
    RerankerProvider,
)

__all__ = [
    "BaseRerankerProvider",
    "RerankerProvider",
]
```

2. Create `agent-brain-server/agent_brain_server/providers/reranker/base.py`:
```python
"""Base protocol and class for reranking providers."""

import logging
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Protocol, runtime_checkable

if TYPE_CHECKING:
    from agent_brain_server.config.provider_config import RerankerConfig

logger = logging.getLogger(__name__)


@runtime_checkable
class RerankerProvider(Protocol):
    """Protocol for reranking providers.

    All reranking providers must implement this interface to be usable
    by the Agent Brain query system for two-stage retrieval.
    """

    async def rerank(
        self,
        query: str,
        documents: list[str],
        top_k: int = 10,
    ) -> list[tuple[int, float]]:
        """Rerank documents for a query.

        Args:
            query: The search query.
            documents: List of document texts to rerank.
            top_k: Number of top results to return.

        Returns:
            List of (original_index, score) tuples, sorted by score descending.
            The original_index refers to the position in the input documents list.

        Raises:
            ProviderError: If reranking fails.
        """
        ...

    @property
    def provider_name(self) -> str:
        """Human-readable provider name for logging."""
        ...

    @property
    def model_name(self) -> str:
        """Model identifier being used."""
        ...

    def is_available(self) -> bool:
        """Check if the provider is available and ready.

        Returns:
            True if provider can perform reranking, False otherwise.
        """
        ...


class BaseRerankerProvider(ABC):
    """Base class for reranking providers with common functionality."""

    def __init__(self, config: "RerankerConfig") -> None:
        """Initialize the reranker provider.

        Args:
            config: Reranker configuration.
        """
        self._model = config.model
        self._batch_size = config.params.get("batch_size", 32)
        self._config = config
        logger.info(
            f"Initialized {self.provider_name} reranker with model {self._model}"
        )

    @property
    def model_name(self) -> str:
        """Model identifier being used."""
        return self._model

    @abstractmethod
    async def rerank(
        self,
        query: str,
        documents: list[str],
        top_k: int = 10,
    ) -> list[tuple[int, float]]:
        """Provider-specific reranking implementation."""
        ...

    @property
    @abstractmethod
    def provider_name(self) -> str:
        """Human-readable provider name for logging."""
        ...

    def is_available(self) -> bool:
        """Default implementation - override if availability check needed."""
        return True
```

Create the directory first if needed:
```bash
mkdir -p agent-brain-server/agent_brain_server/providers/reranker
```
  </action>
  <verify>Run `poetry run python -c "from agent_brain_server.providers.reranker import RerankerProvider, BaseRerankerProvider; print('Imports work')"` to verify the package is importable.</verify>
  <done>Reranker package exists with RerankerProvider protocol and BaseRerankerProvider class.</done>
</task>

<task type="auto">
  <name>Task 2: Add reranker registry methods to ProviderRegistry</name>
  <files>agent-brain-server/agent_brain_server/providers/factory.py</files>
  <action>
Update the ProviderRegistry class to support reranker providers:

1. Add RerankerConfig to TYPE_CHECKING imports:
```python
if TYPE_CHECKING:
    from agent_brain_server.config.provider_config import (
        EmbeddingConfig,
        SummarizationConfig,
        RerankerConfig,
    )
    from agent_brain_server.providers.base import (
        EmbeddingProvider,
        SummarizationProvider,
    )
    from agent_brain_server.providers.reranker.base import RerankerProvider
```

2. Add reranker provider registry dict:
```python
class ProviderRegistry:
    """Registry for provider implementations..."""

    _embedding_providers: dict[str, type[Any]] = {}
    _summarization_providers: dict[str, type[Any]] = {}
    _reranker_providers: dict[str, type[Any]] = {}  # NEW
    _instances: dict[str, Any] = {}
```

3. Add register method:
```python
@classmethod
def register_reranker_provider(
    cls,
    provider_type: str,
    provider_class: type["RerankerProvider"],
) -> None:
    """Register a reranking provider class.

    Args:
        provider_type: Provider identifier (e.g., 'sentence-transformers', 'ollama')
        provider_class: Provider class implementing RerankerProvider protocol
    """
    cls._reranker_providers[provider_type] = provider_class
    logger.debug(f"Registered reranker provider: {provider_type}")
```

4. Add get method:
```python
@classmethod
def get_reranker_provider(cls, config: "RerankerConfig") -> "RerankerProvider":
    """Get or create reranker provider instance.

    Args:
        config: Reranker provider configuration

    Returns:
        Configured RerankerProvider instance

    Raises:
        ProviderNotFoundError: If provider type is not registered
    """
    # Get provider type as string value
    provider_type = (
        config.provider.value
        if hasattr(config.provider, "value")
        else str(config.provider)
    )
    cache_key = f"rerank:{provider_type}:{config.model}"

    if cache_key not in cls._instances:
        provider_class = cls._reranker_providers.get(provider_type)
        if not provider_class:
            available = list(cls._reranker_providers.keys())
            raise ProviderNotFoundError(
                f"Unknown reranker provider: {provider_type}. "
                f"Available: {', '.join(available) if available else 'none'}",
                provider_type,
            )
        cls._instances[cache_key] = provider_class(config)
        logger.info(
            f"Created {provider_type} reranker provider with model {config.model}"
        )

    from agent_brain_server.providers.reranker.base import RerankerProvider

    return cast(RerankerProvider, cls._instances[cache_key])
```

5. Add list method:
```python
@classmethod
def get_available_reranker_providers(cls) -> list[str]:
    """Get list of registered reranker provider types."""
    return list(cls._reranker_providers.keys())
```
  </action>
  <verify>Run `poetry run python -c "from agent_brain_server.providers.factory import ProviderRegistry; print(ProviderRegistry.get_available_reranker_providers())"` to verify the registry methods exist and return empty list initially.</verify>
  <done>ProviderRegistry has register_reranker_provider, get_reranker_provider, and get_available_reranker_providers methods.</done>
</task>

</tasks>

<verification>
1. RerankerProvider protocol has async rerank method with correct signature
2. BaseRerankerProvider has config initialization and abstract methods
3. ProviderRegistry can register and retrieve reranker providers
4. All imports resolve without circular dependencies
</verification>

<success_criteria>
- RerankerProvider protocol is runtime_checkable
- BaseRerankerProvider follows pattern of BaseEmbeddingProvider
- Factory registry has all three reranker methods
- No circular import issues between factory and reranker package
</success_criteria>

<output>
After completion, create `.planning/phases/01-two-stage-reranking/01-02-SUMMARY.md`
</output>
