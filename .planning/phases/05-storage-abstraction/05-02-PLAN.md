---
phase: 05-storage-abstraction
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - agent-brain-server/agent_brain_server/storage/chroma/__init__.py
  - agent-brain-server/agent_brain_server/storage/chroma/backend.py
  - agent-brain-server/agent_brain_server/storage/__init__.py
  - agent-brain-server/agent_brain_server/storage/factory.py
  - agent-brain-server/agent_brain_server/services/query_service.py
  - agent-brain-server/agent_brain_server/services/indexing_service.py
  - agent-brain-server/agent_brain_server/api/main.py
  - agent-brain-server/tests/unit/storage/test_chroma_backend.py
  - agent-brain-server/tests/unit/storage/test_factory.py
  - agent-brain-server/tests/unit/services/test_query_service.py
  - agent-brain-server/tests/unit/services/test_indexing_service.py
autonomous: true

must_haves:
  truths:
    - "ChromaBackend implements StorageBackendProtocol by wrapping VectorStoreManager and BM25IndexManager"
    - "QueryService depends only on StorageBackendProtocol, not VectorStoreManager or BM25IndexManager directly"
    - "IndexingService depends only on StorageBackendProtocol, not VectorStoreManager or BM25IndexManager directly"
    - "get_storage_backend() returns a ChromaBackend when backend='chroma'"
    - "All 505+ existing tests pass without regression after service refactor"
    - "keyword_search returns SearchResult with normalized 0-1 scores (not raw BM25 scores)"
    - "Server startup initializes storage backend via factory"
  artifacts:
    - path: "agent-brain-server/agent_brain_server/storage/chroma/backend.py"
      provides: "ChromaBackend implementing StorageBackendProtocol"
      exports: ["ChromaBackend"]
    - path: "agent-brain-server/agent_brain_server/storage/chroma/__init__.py"
      provides: "ChromaDB backend package exports"
      exports: ["ChromaBackend"]
    - path: "agent-brain-server/agent_brain_server/storage/__init__.py"
      provides: "Updated exports including get_storage_backend"
      exports: ["get_storage_backend", "StorageBackendProtocol"]
    - path: "agent-brain-server/agent_brain_server/services/query_service.py"
      provides: "QueryService using StorageBackendProtocol"
      contains: "StorageBackendProtocol"
    - path: "agent-brain-server/agent_brain_server/services/indexing_service.py"
      provides: "IndexingService using StorageBackendProtocol"
      contains: "StorageBackendProtocol"
  key_links:
    - from: "agent-brain-server/agent_brain_server/storage/chroma/backend.py"
      to: "agent-brain-server/agent_brain_server/storage/vector_store.py"
      via: "wraps VectorStoreManager methods in protocol interface"
      pattern: "self\\.vector_store\\."
    - from: "agent-brain-server/agent_brain_server/storage/chroma/backend.py"
      to: "agent-brain-server/agent_brain_server/indexing/bm25_index.py"
      via: "wraps BM25IndexManager for keyword_search"
      pattern: "self\\.bm25_manager\\."
    - from: "agent-brain-server/agent_brain_server/services/query_service.py"
      to: "agent-brain-server/agent_brain_server/storage/protocol.py"
      via: "depends on StorageBackendProtocol interface"
      pattern: "storage_backend.*StorageBackendProtocol"
    - from: "agent-brain-server/agent_brain_server/storage/factory.py"
      to: "agent-brain-server/agent_brain_server/storage/chroma/backend.py"
      via: "factory creates ChromaBackend when backend='chroma'"
      pattern: "ChromaBackend"
---

<objective>
Implement ChromaBackend adapter wrapping VectorStoreManager and BM25IndexManager, then refactor QueryService and IndexingService to depend only on StorageBackendProtocol.

Purpose: Complete the storage abstraction (STOR-02, STOR-04) so services are backend-agnostic. ChromaDB functionality is preserved through the adapter pattern, and no existing behavior changes.

Output: ChromaBackend adapter, refactored services, updated factory, comprehensive tests proving zero regression.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-storage-abstraction/05-RESEARCH.md
@.planning/phases/05-storage-abstraction/05-01-SUMMARY.md
@agent-brain-server/agent_brain_server/storage/vector_store.py
@agent-brain-server/agent_brain_server/storage/protocol.py
@agent-brain-server/agent_brain_server/storage/factory.py
@agent-brain-server/agent_brain_server/indexing/bm25_index.py
@agent-brain-server/agent_brain_server/services/query_service.py
@agent-brain-server/agent_brain_server/services/indexing_service.py
@agent-brain-server/agent_brain_server/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChromaBackend adapter implementing StorageBackendProtocol</name>
  <files>
    agent-brain-server/agent_brain_server/storage/chroma/__init__.py
    agent-brain-server/agent_brain_server/storage/chroma/backend.py
    agent-brain-server/agent_brain_server/storage/__init__.py
    agent-brain-server/agent_brain_server/storage/factory.py
    agent-brain-server/tests/unit/storage/test_chroma_backend.py
    agent-brain-server/tests/unit/storage/test_factory.py
  </files>
  <action>
**A. Create `storage/chroma/__init__.py`:**
Export `ChromaBackend` from the package.

**B. Create `storage/chroma/backend.py`:**

Implement `ChromaBackend` class that wraps existing `VectorStoreManager` and `BM25IndexManager` to satisfy `StorageBackendProtocol`. Key implementation details:

1. **Constructor** takes optional `vector_store: VectorStoreManager` and `bm25_manager: BM25IndexManager`. If not provided, use existing singletons via `get_vector_store()` and `get_bm25_manager()` (lazy import to avoid circular deps).

2. **`initialize()`** — Delegate to `self.vector_store.initialize()` and `self.bm25_manager.initialize()` (BM25 init is sync, wrap in `asyncio.to_thread()`).

3. **`upsert_documents()`** — Call `self.vector_store.upsert_documents()` for vector storage. Then build/update BM25 index by converting to LlamaIndex TextNode objects and calling `self.bm25_manager.build_index()` wrapped in `asyncio.to_thread()`. IMPORTANT: The existing indexing_service builds BM25 index via `build_index()` with ALL nodes, not incremental adds. The ChromaBackend upsert should NOT rebuild BM25 — that's the indexing_service's responsibility. ChromaBackend.upsert_documents() only upserts to vector store. BM25 rebuilding stays in indexing_service for now. Document this clearly in a comment.

4. **`vector_search()`** — Delegate directly to `self.vector_store.similarity_search()`. The existing method already returns `SearchResult` with cosine similarity (0-1 range). Import and return results using the EXISTING `SearchResult` from `vector_store.py` (not the protocol one) for now. These are identical dataclasses.

5. **`keyword_search()`** — Wrap `self.bm25_manager.search_with_filters()` in `asyncio.to_thread()` if it's sync, or call directly if async (it IS async — uses `retriever.aretrieve()`). Convert `NodeWithScore` results to protocol `SearchResult` objects. CRITICAL: Normalize BM25 scores to 0-1 range by dividing by max_score in the result set (per-query normalization). If no results, return empty list.

6. **`get_count()`** — Delegate to `self.vector_store.get_count()`.

7. **`get_by_id()`** — Delegate to `self.vector_store.get_by_id()`.

8. **`reset()`** — Call `self.vector_store.reset()` and `asyncio.to_thread(self.bm25_manager.reset)`.

9. **`get_embedding_metadata()` / `set_embedding_metadata()`** — Delegate to `self.vector_store.get_embedding_metadata()` and `self.vector_store.set_embedding_metadata()`. Return protocol's `EmbeddingMetadata` (identical structure).

10. **`validate_embedding_compatibility()`** — Delegate to `self.vector_store.validate_embedding_compatibility()`.

11. **`is_initialized` property** — Return `self.vector_store.is_initialized`.

IMPORTANT: Do NOT move `vector_store.py` to `storage/chroma/` in this plan. Keep the existing file in place. `ChromaBackend` wraps it via composition, not by moving code. This minimizes risk of breaking existing imports throughout the codebase.

**C. Update `storage/__init__.py`:**
Add exports for `get_storage_backend`, `StorageBackendProtocol`, `SearchResult` (from protocol). Keep ALL existing exports (VectorStoreManager, get_vector_store, etc.) for backward compatibility.

**D. Update `storage/factory.py`:**
Replace the `NotImplementedError` for "chroma" with actual `ChromaBackend` creation:
```python
if backend_type == "chroma":
    from agent_brain_server.storage.chroma.backend import ChromaBackend
    return ChromaBackend()
```
Keep "postgres" as `NotImplementedError`.

**E. Update `tests/unit/storage/test_factory.py`:**
Update the factory test that previously expected `NotImplementedError` for "chroma" to now verify it returns a `ChromaBackend` instance. Keep "postgres" test as `NotImplementedError`.

**F. Create `tests/unit/storage/test_chroma_backend.py`:**
1. Test ChromaBackend constructor with mocked VectorStoreManager and BM25IndexManager
2. Test `initialize()` delegates to both managers
3. Test `vector_search()` delegates to vector_store.similarity_search and returns SearchResult list
4. Test `keyword_search()` calls bm25_manager.search_with_filters, converts NodeWithScore to SearchResult, normalizes scores to 0-1
5. Test `keyword_search()` with empty results returns empty list
6. Test `get_count()` delegates to vector_store
7. Test `reset()` calls both vector_store.reset and bm25_manager.reset
8. Test `is_initialized` property delegates to vector_store
9. Test `get_embedding_metadata()` and `set_embedding_metadata()` delegate to vector_store
10. Test that ChromaBackend satisfies `isinstance(backend, StorageBackendProtocol)` check

Use `unittest.mock.AsyncMock` for async methods, `MagicMock` for sync properties. Follow existing test patterns in `tests/unit/storage/`.
  </action>
  <verify>
Run: `cd agent-brain-server && poetry run mypy agent_brain_server/storage/chroma/ agent_brain_server/storage/factory.py agent_brain_server/storage/__init__.py --strict`
Run: `cd agent-brain-server && poetry run pytest tests/unit/storage/test_chroma_backend.py tests/unit/storage/test_factory.py -v`
Run: `cd agent-brain-server && poetry run pytest` — all existing tests must still pass
Verify: ChromaBackend implements protocol, all new tests pass, zero regressions.
  </verify>
  <done>
ChromaBackend wraps VectorStoreManager and BM25IndexManager, implementing all StorageBackendProtocol methods. Factory creates ChromaBackend for "chroma" config. All tests pass including new ChromaBackend unit tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor services to depend on StorageBackendProtocol</name>
  <files>
    agent-brain-server/agent_brain_server/services/query_service.py
    agent-brain-server/agent_brain_server/services/indexing_service.py
    agent-brain-server/agent_brain_server/api/main.py
  </files>
  <action>
**CRITICAL CONSTRAINT:** This refactor MUST be backward-compatible. Services must accept BOTH the old constructor args (vector_store + bm25_manager) and new constructor arg (storage_backend). Existing tests that construct services with mocked VectorStoreManager/BM25IndexManager must continue to work.

**A. Refactor `services/query_service.py`:**

1. Add `storage_backend: StorageBackendProtocol | None = None` parameter to `__init__`. Keep existing `vector_store` and `bm25_manager` params for backward compat.
2. Resolution logic in `__init__`:
   ```python
   if storage_backend is not None:
       self.storage_backend = storage_backend
   elif vector_store is not None or bm25_manager is not None:
       # Legacy path: wrap provided stores in ChromaBackend
       from agent_brain_server.storage.chroma.backend import ChromaBackend
       self.storage_backend = ChromaBackend(
           vector_store=vector_store,
           bm25_manager=bm25_manager,
       )
   else:
       from agent_brain_server.storage.factory import get_storage_backend
       self.storage_backend = get_storage_backend()
   ```
3. Keep `self.vector_store` and `self.bm25_manager` as ALIASES pointing into the ChromaBackend for backward compat with any code that accesses them directly (e.g., `VectorManagerRetriever` accesses `self.service.vector_store`). If storage_backend is ChromaBackend, extract .vector_store and .bm25_manager. If not, set both to None (will break graph/reranker code that accesses them — but for Phase 5 that's fine since only chroma backend exists).
4. Update `_execute_vector_query()`: Replace `self.vector_store.similarity_search()` with `self.storage_backend.vector_search()`. The return type is identical (SearchResult).
5. Update `_execute_bm25_query()`: Replace direct bm25_manager usage with `self.storage_backend.keyword_search()`. Convert returned `SearchResult` objects to `QueryResult` objects (same as existing conversion pattern but from SearchResult instead of NodeWithScore).
6. Update `_execute_hybrid_query()`: Replace both vector_store and bm25_manager calls with `self.storage_backend.vector_search()` and `self.storage_backend.keyword_search()`. BM25 scores are already normalized 0-1 by ChromaBackend's keyword_search, so adjust normalization logic accordingly (no need to normalize again — keyword_search results are pre-normalized).
7. Update `is_ready()`: Use `self.storage_backend.is_initialized`.
8. Update `get_count()` / corpus_size calls: Use `self.storage_backend.get_count()`.
9. KEEP `VectorManagerRetriever` class for now — it's used by the reranking pipeline. Update it to use `self.storage_backend.vector_search()` via the service reference instead of `self.service.vector_store.similarity_search()`.
10. KEEP `graph_index_manager` — GraphRAG is NOT part of the storage protocol.

**B. Refactor `services/indexing_service.py`:**

1. Add `storage_backend: StorageBackendProtocol | None = None` parameter to `__init__`. Keep existing params for backward compat (same resolution logic as QueryService).
2. Keep `self.vector_store` and `self.bm25_manager` as aliases for backward compat.
3. Update document upsert calls: Replace `self.vector_store.upsert_documents()` and `self.vector_store.add_documents()` with `self.storage_backend.upsert_documents()`.
4. Update embedding metadata calls: Replace `self.vector_store.get_embedding_metadata()` / `set_embedding_metadata()` / `validate_embedding_compatibility()` with `self.storage_backend.*` equivalents.
5. BM25 index building: KEEP the existing BM25 rebuild logic in indexing_service (`self.bm25_manager.build_index(nodes)`). The BM25 rebuild is a full-corpus operation that happens after all chunks are created. For the chroma backend, access `self.bm25_manager` directly (via the alias). For future PostgreSQL backend, keyword indexing is handled automatically by tsvector triggers, so this code path won't execute.
6. KEEP `graph_index_manager` — not part of storage protocol.

**C. Update `api/main.py` startup:**

In the existing `lifespan` function, add storage backend initialization:
1. After existing vector store initialization, also get the storage backend via factory and initialize it.
2. This is a light touch — the existing `initialize_vector_store()` call already initializes ChromaDB. The storage backend's `initialize()` will be a no-op in most cases since it delegates to the same VectorStoreManager singleton.
3. Add a log line: `logger.info(f"Storage backend: {get_effective_backend_type()}")`
4. Add startup validation: If `get_effective_backend_type()` returns an unknown value, log an error and fail fast.

**IMPORTANT:** Take extreme care with backward compat. The existing test suite constructs QueryService and IndexingService with `vector_store=mock_vector_store, bm25_manager=mock_bm25` in dozens of tests. The new code MUST still accept this pattern.
  </action>
  <verify>
Run: `cd agent-brain-server && poetry run mypy agent_brain_server/services/ agent_brain_server/api/main.py --strict`
Run: `cd agent-brain-server && poetry run pytest` — ALL 505+ tests must pass
Run: `task before-push` — full quality gate
Verify: Services use storage_backend protocol. Backward compat maintained. Zero test regressions.
  </verify>
  <done>
QueryService and IndexingService accept StorageBackendProtocol. Backward compat maintained — existing test patterns with mock vector_store/bm25_manager still work. Server startup logs storage backend type. All 505+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration verification and test updates</name>
  <files>
    agent-brain-server/tests/unit/services/test_query_service.py
    agent-brain-server/tests/unit/services/test_indexing_service.py
  </files>
  <action>
**A. Review and update service tests for protocol-based construction:**

1. Review all existing service tests that construct QueryService or IndexingService. Most should continue working via backward-compat paths. Identify any tests that access `service.vector_store` or `service.bm25_manager` directly and verify the aliases work.

2. Add NEW tests in existing test files that construct services with `storage_backend=mock_backend` where `mock_backend` is an `AsyncMock` implementing StorageBackendProtocol methods:

For `test_query_service.py`, add:
- `test_query_service_with_storage_backend_protocol` — Construct QueryService with a mock StorageBackendProtocol, verify `_execute_vector_query` calls `mock_backend.vector_search()`
- `test_bm25_query_with_storage_backend` — Verify `_execute_bm25_query` calls `mock_backend.keyword_search()` and returns results
- `test_hybrid_query_with_storage_backend` — Verify hybrid query uses both `vector_search()` and `keyword_search()` from the backend

For `test_indexing_service.py`, add:
- `test_indexing_service_with_storage_backend` — Construct with mock backend, verify upsert and embedding metadata calls go through backend

3. Verify no service test imports `chromadb` directly (leaky abstraction check).

**B. Run comprehensive verification:**

1. `poetry run pytest` — all tests pass
2. `poetry run ruff check agent_brain_server tests` — no lint errors
3. `poetry run black --check agent_brain_server tests` — formatting clean
4. `poetry run mypy agent_brain_server` — type checking passes
5. `task before-push` — full quality gate

**C. Verify STOR-04 compliance:**

Grep services for direct chromadb imports:
- `grep -r "from chromadb" agent_brain_server/services/` should return NO results
- `grep -r "import chromadb" agent_brain_server/services/` should return NO results
- Services should only import from `storage.protocol` or `storage` (not `storage.vector_store` or `indexing.bm25_index`)

EXCEPTION: It's acceptable for services to still import `BM25IndexManager` type for the BM25 rebuild in indexing_service. This is a known compromise — full BM25 abstraction requires ChromaBackend to handle incremental BM25 updates, which is deferred. Document this as a known limitation.

**D. Verify backward compatibility:**

Run specifically the tests that test the existing API behavior:
- `poetry run pytest tests/unit/services/ -v` — all service unit tests pass
- `poetry run pytest tests/integration/ -v` — integration tests pass (if they exist and don't need API keys)
- `poetry run pytest tests/contract/ -v` — contract tests pass
  </action>
  <verify>
Run: `task before-push` — MUST pass with exit code 0
Run: `cd agent-brain-server && poetry run pytest --tb=short -q` — count should be >= 505 tests passing
Verify: Full quality gate passes, test count >= 505, no service imports chromadb directly (STOR-04), backward compat confirmed.
  </verify>
  <done>
All 505+ tests pass. Services depend on StorageBackendProtocol (STOR-04 verified). New protocol-based service tests added. No direct chromadb imports in services (except documented BM25 exception). `task before-push` passes clean.
  </done>
</task>

</tasks>

<verification>
1. `task before-push` passes with exit code 0
2. `cd agent-brain-server && poetry run pytest --tb=short -q` — 505+ tests passing, zero failures
3. `cd agent-brain-server && poetry run mypy agent_brain_server --strict` — no type errors
4. ChromaBackend satisfies StorageBackendProtocol (verified by isinstance check in tests)
5. Services accept both old (vector_store/bm25_manager) and new (storage_backend) constructor patterns
6. No direct `chromadb` imports in `services/` directory (grep verification)
7. Factory returns ChromaBackend for "chroma" config
8. Server startup logs storage backend type
</verification>

<success_criteria>
- STOR-02: ChromaBackend implements StorageBackendProtocol via VectorStoreManager + BM25IndexManager wrappers
- STOR-03: Factory selects ChromaBackend based on YAML config
- STOR-04: Services depend only on StorageBackendProtocol interface (with documented BM25 exception in indexing_service)
- All 505+ existing tests pass (zero regressions)
- keyword_search normalizes BM25 scores to 0-1 range
- Backward-compatible constructor patterns preserved for all existing test code
- `task before-push` passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/05-storage-abstraction/05-02-SUMMARY.md`
</output>
